---
layout: post
title:  "Remote Play Anything, A Very Rough Prototype"
date:   2025-7-20 12:46:00 +0200
categories: [Projects, Selfhosted Gamestream Service]
tags: [Embedded, UART, Streaming, MicroController, Linux]
image:
  path: /assets/img/remote-play-anything-mk1/stream-live.png
  alt: An over-engineered solution to a problem that nobody has.
---
# Overview
Gaming in general is one of my favorite hobbies. There’s a lot of reasons for this, but it’s mostly because I love exploring the other worlds that people like to make in their free time. There’s no other media quite like it. It’s interactive, and that alone makes accessibility a bit more of a challenge. For example, with your favorite movie, you can probably stream it off Netflix or something on just about anything you own. The same can’t be said about your favorite game though. More than likely, your favorite game might be tied to a specific piece of hardware or be too graphically demanding to run on the gear you’re going to have with you day to day. Remote Play Anything is my answer to that. The goal is to cut down those barriers to make it so you can play any game from any console on any device you want. 

Now that might sound like an overly ambitious goal, but the puzzle pieces have never lined up quite this cleanly before. When you really boil it down, all that's needed is 3 simple things. You need the video output of the game you’re going to be playing. This could be obtained in many ways, like simply via PC screen capture or a physical capture card for a physical console. The next thing we need is user input. PC games are easy since you can literally program the platform from the ground up if you want, so that’s not as big of a worry. But for physical game consoles, things get a bit more interesting. All physical game consoles accept user input in some way. 90% of the time, this takes the form of something like an Xbox controller. As long as you provide the right signals in the way the console is expecting them to look, you’ve got yourself user input. The last part is the actual streaming over the internet component. You need some kinda client and server to get your video feed and user input to and from the location you want your games to be.

# Streaming Medium: Sunshine / Moonlight
Let’s start with the client / server part. This may sound like the most complicated piece, but the good news is that there’s many many open-source projects that can fit the bill here. I go a bit more in depth on this in one of my other projects, the [Selfhosted Gamestreaming Server Prototype](/posts/selfhosted-gamestreaming-server-prototype/). I’ll be making use of Sunshine and Moonlight here as my streaming medium, but the actual content that’ll be streamed is going to be handled very differently. 

# Video & Audio Capture
So with Sunshine and Moonlight providing the streaming backend, the next step becomes obtaining video from the console. I made use of a physical capture card to intercept the HDMI output of a Playstation 3 and render it on a PC. I wanted to keep this fairly lightweight, so instead of using something like VLC to show the capture card output, I simply made use of ffmpeg directly and a couple of highly specialized commands to try and get the lowest possible latency. There are 2 main commands that do different jobs. One displays video output to the screen, the other plays back the captured audio in real time. Since they are two different program instances running side by side, it is possible that one gets ever so slightly ahead of the other, but it’s nothing too jarring. You have to really look close to notice, but it is something to note for future revisions.

**Audio:**
```bash
ffplay -f alsa -i hw:1,0 -nodisp -autoexit -fflags nobuffer -flags low_delay -analyzeduration 0 -probesize 32
```
**Video:**
```bash
ffplay -fs -f v4l2 -video_size 1920x1080 -framerate 60 -pixel_format yuyv422 -i /dev/video0 -fflags nobuffer -flags low_delay -framedrop
```

# Controller Input Forwarding
Now here comes the hard part, user input. Sunshine and moonlight handle getting user input from the remote location and providing it on the local PC. This is a great start, but unfortunately is not good enough for a physical console. You need to have some kinda way to take this digital signal generated by sunshine and turn it into, basically a physical controller. The good news is I have done exactly that, but it was anything but simple and still needs a ton of work before it can be considered ready for prime time. 

![Photo of various hardware necessary for streaming other devices.](/assets/img/remote-play-anything-mk1/streaming-hardware-outline.png){: width="auto"}

So we’ll start off with a quick outline of what this hardware actually is. The cable is actually a single micro-controller (arduino micro) that effectively has two hosts. This is not really something that’s supported by micro controller workflows so I had to get a bit creative. The end that plugs into the PC is actually a UART communication line. This means that anything communicated to the micro-controller from the PC must be done via the UART protocol in software. The other end is the standard arduino serial line, and that runs to the console you’re wanting to enable remote play for. The micro controller itself currently simulates a basic XInput device (Xbox 360 Controller) and nothing else, so the added adapter on the end is a [Mayflash Magic-NS](https://www.mayflash.com/product/magic_ns_usb_wireless_controller_adapter.html) to convert that into any console controller I want. In the future, I’d like to compile all that functionality into a single dongle, but for now due to the complexity of the project, this frankenstine cable does the job well enough.

So the micro-controller acts basically as a repeater. There’s a simple python program written on the PC host that intercepts any XInput controller signals provided by sunshine. That software then boils that information down into a single string data packet. 

```python
packet = struct.pack('<HBhhhhBB', buttons, dpad, lx, ly, rx, ry, lt, rt)
```

Every number in the string represents a different value of the controller state such as what button is pressed, how far a trigger is pulled, or the position of the analog sticks. This single string data packet is then sent via uart to the micro-controller. Timing on these packets is crucial! Data is sent via UART at a high polling rate, so it's very possible that a packet gets to the micro controller in a mangled or corrupted state. A simple header value at the beginning of the packet helps the software correct for timing errors and data loss.

Once the micro-controller receives the data packet, it has a very important job. It needs to simulate being a XInput device itself, and change it’s state to match that of the packet. What this effectively means is that it’s using software from the PC host to emulate a Xbox Controller, then send that signal out via USB, all without needing direct user input. This is huge accomplishment because it means that a PC can directly interact with any console and do any action as if it were a person! No hacky workaround required.

# Video Demo
With all the pieces in place here, you can start to see the vision. The dedicated PC handles all the complexity of capture, input forwarding, and ota streaming, while the console stays in it’s original, unmodified format. Below is a demo video of the tech in action streaming a stock Playstation 3 to a Steam Deck.

{% include embed/youtube.html id='xOE1qzyS1uQ' %}
_"[Remote Play Anything - Initial Prototype](https://www.youtube.com/watch?v=xOE1qzyS1uQ)" by Dawson Thompson_

# What's Next?
This little experiment has proved wildly more successful than I could’ve hoped for! There’s definitely still a lot of work to be done here, but this proof of concept is enough to keep the project going. Through my very unscientific method of testing by using my eyeballs to stare at the screen, I'd say there's about 1-1.5 seconds of delay between when you press a button on the remote device (like the steam deck) and see the intended reaction. That number is extremely consistent though, and there's a lot going on under the hood. I suspect that number can be cut down by code optimization, some custom hardware, and cutting down the number of adapter layers. The more that this complexity and be cut down into a single hardware dongle, the more likely it is that latency improves.

The other current concern is that this is very much still in the "wow this works somehow" phase. I'd want to containerize this software so that it becomes more easily deployable. That has it's own share of headaches though as I may have already attempted that and found out you need to practially build a desktop inside a container to get that working. Definitely not impossible, but it's complicated.

For now though I'm extremely happy with where this prototype landed. With some more work the right controller simulation, you’d be able to remote play pretty much any modern console / PC you could want!

